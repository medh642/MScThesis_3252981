[
  {
    "query": "Load the Netherlands_Landuse.gpkg layer and print the total number of agricultural polygons (category = 'Bouwland').",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          },
          {
            "path": "inputdata\\RotterdamLULC.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 9729,
            "fields": [
              "id",
              "OBJECTID",
              "country",
              "fua_name",
              "fua_code",
              "code_2018",
              "class_2018",
              "prod_date",
              "identifier",
              "perimeter",
              "area",
              "comment",
              "Shape_Leng",
              "Shape_Area",
              "geometry"
            ],
            "bounds": [
              84436.32742184984,
              430538.6686652378,
              101190.75927472248,
              445600.6355960344
            ]
          },
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          }
        ],
        "python_docs": [
          "n\n>>> polygon_with_hole = Polygon(\n...     [(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)],\n...     holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]]\n... )\n>>> shapely.get_rings(polygon_with_hole).tolist()\n[<LINEARRING (0 0, 0 10, 10 10, 10 0, 0 0)>,\n <LINEARRING (2 2, 2 4, 4 4, 4 2, 2 2)>]\n\nWith ``return_index=True``:\n\n>>> polygon = Polygon([(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)])\n>>> rings, index = shapely.get_rings(\n...     [polygon, polygon_with_hole],\n...     return_index=True\n... )\n>>> rings.tolist()\n[<LINEARRING (0 0, 2 0, 2 2, 0 2, 0 0)>,\n <LINEARRING (0 0, 0 10, 10 10, 10 0, 0 0)>,\n <LINEARRING (2 2, 2 4, 4 4, 4 2, 2 2)>]\n>>> index.tolist()\n[0, 1, 1]",
          "Print system information and installed module versions.\n\nExamples\n--------\n::\n\n    $ python -c \"import geopandas; geopandas.show_versions()\"",
          "Create polygons formed from the linework of a set of Geometries.\n\nPolygonizes an array of Geometries that contain linework which\nrepresents the edges of a planar graph. Any type of Geometry may be\nprovided as input; only the constituent lines and rings will be used to\ncreate the output polygons.\n\nLines or rings that when combined do not completely close a polygon\nwill result in an empty GeometryCollection.  Duplicate segments are\nignored.\n\nThis function returns the polygons within a GeometryCollection.\nIndividual Polygons can be obtained using ``get_geometry`` to get\na single polygon or ``get_parts`` to get an array of polygons.\nMultiPolygons can be constructed from the output using\n``shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries)))``.\n\nParameters\n----------\ngeometries : array_like\n    An array of geometries.\naxis : int\n    Axis along which the geometries are polygonized.\n    The default is to perform a reduction over the last dimension\n    of the input array. A 1D array results in a scalar geometry.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nReturns\n-------\nGeometryCollection or array of GeometryCollections\n\nSee A"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] n\n>>> polygon_with_hole = Polygon(\n...     [(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)],\n...     holes=[[(2, 2), (2, 4), (4, 4), (4, 2), (2, 2)]]\n... )\n>>> shapely.get_rings(polygon_with_hole).tolist()\n[<LINEARRING (0 0, 0 10, 10 10, 10 0, 0 0)>,\n <LINEARRING (2 2, 2 4, 4 4, 4 2, 2 2)>]\n\nWith ``return_index=True``:\n\n>>> polygon = Polygon([(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)])\n>>> rings, index = shapely.get_rings(\n...     [polygon, polygon_with_hole],\n...     return_index=True\n... )\n>>> rings.tolist()\n[<LINEARRING (0 0, 2 0, 2 2, 0 2, 0 0)>,\n <LINEARRING (0 0, 0 10, 10 10, 10 0, 0 0)>,\n <LINEARRING (2 2, 2 4, 4 4, 4 2, 2 2)>]\n>>> index.tolist()\n[0, 1, 1]\nMetadata: {\"library\": \"shapely\", \"object_name\": \"shapely.get_rings\", \"retrieved_at\": \"2025-11-20T13:02:26.130085+00:00\"}\n\n[Python_docs] Print system information and installed module versions.\n\nExamples\n--------\n::\n\n    $ python -c \"import geopandas; geopandas.show_versions()\"\nMetadata: {\"object_name\": \"geopandas.show_versions\", \"retrieved_at\": \"2025-11-20T13:02:25.201695+00:00\", \"library\": \"geopandas\"}\n\n[Python_docs] Create polygons formed from the linework of a set of Geometries.\n\nPolygonizes an array of Geometries that contain linework which\nrepresents the edges of a planar graph. Any type of Geometry may be\nprovided as input; only the constituent lines and rings will be used to\ncreate the output polygons.\n\nLines or rings that when combined do not completely close a polygon\nwill result in an empty GeometryCollection.  Duplicate segments are\nignored.\n\nThis function returns the polygons within a GeometryCollection.\nIndividual Polygons can be obtained using ``get_geometry`` to get\na single polygon or ``get_parts`` to get an array of polygons.\nMultiPolygons can be constructed from the output using\n``shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries)))``.\n\nParameters\n----------\ngeometries : array_like\n    An array of geometries.\naxis : int\n    Axis along which the geometries are polygonized.\n    The default is to perform a reduction over the last dimension\n    of the input array. A 1D array results in a scalar geometry.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nReturns\n-------\nGeometryCollection or array of GeometryCollections\n\nSee A\nMetadata: {\"library\": \"shapely\", \"retrieved_at\": \"2025-11-20T13:02:26.130443+00:00\", \"object_name\": \"shapely.polygonize\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"type\": \"vector\", \"geometry_type\": \"[\\\"Polygon\\\"]\", \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"num_features\": 2338483, \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\RotterdamLULC.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 9729,\n  \"fields\": [\n    \"id\",\n    \"OBJECTID\",\n    \"country\",\n    \"fua_name\",\n    \"fua_code\",\n    \"code_2018\",\n    \"class_2018\",\n    \"prod_date\",\n    \"identifier\",\n    \"perimeter\",\n    \"area\",\n    \"comment\",\n    \"Shape_Leng\",\n    \"Shape_Area\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    84436.32742184984,\n    430538.6686652378,\n    101190.75927472248,\n    445600.6355960344\n  ]\n}\nMetadata: {\"path\": \"inputdata\\\\RotterdamLULC.shp\", \"crs\": \"EPSG:28992\", \"num_features\": 9729, \"fields\": \"[\\\"id\\\", \\\"OBJECTID\\\", \\\"country\\\", \\\"fua_name\\\", \\\"fua_code\\\", \\\"code_2018\\\", \\\"class_2018\\\", \\\"prod_date\\\", \\\"identifier\\\", \\\"perimeter\\\", \\\"area\\\", \\\"comment\\\", \\\"Shape_Leng\\\", \\\"Shape_Area\\\", \\\"geometry\\\"]\", \"bounds\": \"[84436.32742184984, 430538.6686652378, 101190.75927472248, 445600.6355960344]\", \"type\": \"vector\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"path\": \"inputdata\\\\NL_Provinces.shp\", \"num_features\": 14, \"type\": \"vector\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\"}"
    ],
    "response": "```python\nimport geopandas as gpd\nfrom shapely.geometry import Polygon\n\n# Load the Netherlands_Landuse.gpkg layer\nnetherlands_landuse = gpd.read_file('inputdata\\\\Netherlands_Landuse.gpkg')\n\n# Filter for agricultural polygons (category = 'Bouwland')\nagricultural_polygons = netherlands_landuse[netherlands_landuse['category'] == 'Bouwland']\n\n# Print the total number of agricultural polygons\nprint(len(agricultural_polygons))\n```"
  },
  {
    "query": "Load the NL_Provinces.shp file and extract the geometry bounds for the province named 'Noord-Holland'.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          },
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          },
          {
            "path": "inputdata\\RotterdamLULC.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 9729,
            "fields": [
              "id",
              "OBJECTID",
              "country",
              "fua_name",
              "fua_code",
              "code_2018",
              "class_2018",
              "prod_date",
              "identifier",
              "perimeter",
              "area",
              "comment",
              "Shape_Leng",
              "Shape_Area",
              "geometry"
            ],
            "bounds": [
              84436.32742184984,
              430538.6686652378,
              101190.75927472248,
              445600.6355960344
            ]
          }
        ],
        "python_docs": [
          "- Y[north]: Northing (metre)\nArea of Use:\n- name: World - 85\u00b0S to 85\u00b0N\n- bounds: (-180.0, -85.06, 180.0, 85.06)\nCoordinate Operation:\n- name: Popular Visualisation Pseudo-Mercator\n- method: Popular Visualisation Pseudo Mercator\nDatum: World Geodetic System 1984\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n>>> s = geopandas.GeoSeries(\n...    [Point(1, 1), Point(2, 2), Point(3, 3)], index=[\"a\", \"b\", \"c\"], crs=4326\n... )\n>>> s\na    POINT (1 1)\nb    POINT (2 2)\nc    POINT (3 3)\ndtype: geometry\n\n>>> s.crs\n<Geographic 2D CRS: EPSG:4326>\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\nSee Also\n--------\nGeoDataFrame\npandas.Series",
          "versions. To mimic this for\nversions before GEOS 3.12, use::\n\n    shapely.to_wkt(geometry, rounding_precision=-1, trim=False, output_dimension=2)",
          "ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] - Y[north]: Northing (metre)\nArea of Use:\n- name: World - 85\u00b0S to 85\u00b0N\n- bounds: (-180.0, -85.06, 180.0, 85.06)\nCoordinate Operation:\n- name: Popular Visualisation Pseudo-Mercator\n- method: Popular Visualisation Pseudo Mercator\nDatum: World Geodetic System 1984\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\n>>> s = geopandas.GeoSeries(\n...    [Point(1, 1), Point(2, 2), Point(3, 3)], index=[\"a\", \"b\", \"c\"], crs=4326\n... )\n>>> s\na    POINT (1 1)\nb    POINT (2 2)\nc    POINT (3 3)\ndtype: geometry\n\n>>> s.crs\n<Geographic 2D CRS: EPSG:4326>\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n\nSee Also\n--------\nGeoDataFrame\npandas.Series\nMetadata: {\"object_name\": \"geopandas.GeoSeries\", \"retrieved_at\": \"2025-11-20T13:02:25.201570+00:00\", \"library\": \"geopandas\"}\n\n[Python_docs] versions. To mimic this for\nversions before GEOS 3.12, use::\n\n    shapely.to_wkt(geometry, rounding_precision=-1, trim=False, output_dimension=2)\nMetadata: {\"object_name\": \"shapely.to_wkt\", \"library\": \"shapely\", \"retrieved_at\": \"2025-11-20T13:02:26.130595+00:00\"}\n\n[Python_docs] ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)\nMetadata: {\"library\": \"geopandas\", \"object_name\": \"geopandas.clip\", \"retrieved_at\": \"2025-11-20T13:02:25.201587+00:00\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"crs\": \"EPSG:28992\", \"num_features\": 14, \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"type\": \"vector\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"type\": \"vector\", \"num_features\": 2338483, \"geometry_type\": \"[\\\"Polygon\\\"]\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\", \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\RotterdamLULC.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 9729,\n  \"fields\": [\n    \"id\",\n    \"OBJECTID\",\n    \"country\",\n    \"fua_name\",\n    \"fua_code\",\n    \"code_2018\",\n    \"class_2018\",\n    \"prod_date\",\n    \"identifier\",\n    \"perimeter\",\n    \"area\",\n    \"comment\",\n    \"Shape_Leng\",\n    \"Shape_Area\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    84436.32742184984,\n    430538.6686652378,\n    101190.75927472248,\n    445600.6355960344\n  ]\n}\nMetadata: {\"crs\": \"EPSG:28992\", \"fields\": \"[\\\"id\\\", \\\"OBJECTID\\\", \\\"country\\\", \\\"fua_name\\\", \\\"fua_code\\\", \\\"code_2018\\\", \\\"class_2018\\\", \\\"prod_date\\\", \\\"identifier\\\", \\\"perimeter\\\", \\\"area\\\", \\\"comment\\\", \\\"Shape_Leng\\\", \\\"Shape_Area\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\RotterdamLULC.shp\", \"num_features\": 9729, \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"type\": \"vector\", \"bounds\": \"[84436.32742184984, 430538.6686652378, 101190.75927472248, 445600.6355960344]\"}"
    ],
    "response": "```python\nimport geopandas as gpd\n\n# Load the NL_Provinces.shp file\nnl_provinces = gpd.read_file('inputdata\\\\NL_Provinces.shp')\n\n# Extract the geometry bounds for the province named 'Noord-Holland'\nnoord_holland_bounds = nl_provinces[nl_provinces['NAME_1'] == 'Noord-Holland'].geometry.bounds\n\nprint(zuid_holland_bounds)\n```"
  },
  {
    "query": "Load the RotterdamLULC.shp dataset and calculate the total area for each class_2018 category.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\RotterdamLULC.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 9729,
            "fields": [
              "id",
              "OBJECTID",
              "country",
              "fua_name",
              "fua_code",
              "code_2018",
              "class_2018",
              "prod_date",
              "identifier",
              "perimeter",
              "area",
              "comment",
              "Shape_Leng",
              "Shape_Area",
              "geometry"
            ],
            "bounds": [
              84436.32742184984,
              430538.6686652378,
              101190.75927472248,
              445600.6355960344
            ]
          },
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          },
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          }
        ],
        "python_docs": [
          "Compute the area of a (multi)polygon.\n\nParameters\n----------\ngeometry : Geometry or array_like\n    Geometry or geometries for which to compute the area.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import MultiPolygon, Polygon\n>>> polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)])\n>>> shapely.area(polygon)\n100.0\n>>> polygon2 = Polygon([(10, 10), (10, 20), (20, 20), (20, 10), (10, 10)])\n>>> shapely.area(MultiPolygon([polygon, polygon2]))\n200.0\n>>> shapely.area(Polygon())\n0.0\n>>> shapely.area(None)\nnan",
          "on.area\n1.0",
          "rt Point, Polygon\n>>> area = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n>>> shapely.contains(area, Point(0.5, 0.5))\nTrue\n>>> shapely.contains_xy(area, 0.5, 0.5)\nTrue"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] Compute the area of a (multi)polygon.\n\nParameters\n----------\ngeometry : Geometry or array_like\n    Geometry or geometries for which to compute the area.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import MultiPolygon, Polygon\n>>> polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)])\n>>> shapely.area(polygon)\n100.0\n>>> polygon2 = Polygon([(10, 10), (10, 20), (20, 20), (20, 10), (10, 10)])\n>>> shapely.area(MultiPolygon([polygon, polygon2]))\n200.0\n>>> shapely.area(Polygon())\n0.0\n>>> shapely.area(None)\nnan\nMetadata: {\"library\": \"shapely\", \"retrieved_at\": \"2025-11-20T13:02:26.129755+00:00\", \"object_name\": \"shapely.area\"}\n\n[Python_docs] on.area\n1.0\nMetadata: {\"library\": \"shapely\", \"retrieved_at\": \"2025-11-20T13:02:26.129740+00:00\", \"object_name\": \"shapely.Polygon\"}\n\n[Python_docs] rt Point, Polygon\n>>> area = Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n>>> shapely.contains(area, Point(0.5, 0.5))\nTrue\n>>> shapely.contains_xy(area, 0.5, 0.5)\nTrue\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:26.129836+00:00\", \"library\": \"shapely\", \"object_name\": \"shapely.contains_xy\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\RotterdamLULC.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 9729,\n  \"fields\": [\n    \"id\",\n    \"OBJECTID\",\n    \"country\",\n    \"fua_name\",\n    \"fua_code\",\n    \"code_2018\",\n    \"class_2018\",\n    \"prod_date\",\n    \"identifier\",\n    \"perimeter\",\n    \"area\",\n    \"comment\",\n    \"Shape_Leng\",\n    \"Shape_Area\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    84436.32742184984,\n    430538.6686652378,\n    101190.75927472248,\n    445600.6355960344\n  ]\n}\nMetadata: {\"type\": \"vector\", \"bounds\": \"[84436.32742184984, 430538.6686652378, 101190.75927472248, 445600.6355960344]\", \"num_features\": 9729, \"path\": \"inputdata\\\\RotterdamLULC.shp\", \"crs\": \"EPSG:28992\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"fields\": \"[\\\"id\\\", \\\"OBJECTID\\\", \\\"country\\\", \\\"fua_name\\\", \\\"fua_code\\\", \\\"code_2018\\\", \\\"class_2018\\\", \\\"prod_date\\\", \\\"identifier\\\", \\\"perimeter\\\", \\\"area\\\", \\\"comment\\\", \\\"Shape_Leng\\\", \\\"Shape_Area\\\", \\\"geometry\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\", \"geometry_type\": \"[\\\"Polygon\\\"]\", \"num_features\": 2338483, \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"type\": \"vector\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"path\": \"inputdata\\\\NL_Provinces.shp\", \"type\": \"vector\", \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\", \"num_features\": 14, \"crs\": \"EPSG:28992\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\"}"
    ],
    "response": "```python\nimport geopandas as gpd\nfrom shapely.geometry import Polygon, MultiPolygon\n\n# Load the RotterdamLULC.shp dataset\nrotterdam_lulc = gpd.read_file('inputdata\\\\RotterdamLULC.shp')\n\n# Calculate the total area for each class_2018 category\nfor index, row in rotterdam_lulc.iterrows():\n    polygon = Polygon(row['geometry'])\n    if isinstance(polygon, MultiPolygon):\n        total_area = sum([polygon.area for polygon in polygon.geoms])\n    else:\n        total_area = polygon.area\n    rotterdam_lulc.loc[index, 'total_area'] = total_area\n\n# Print the updated dataframe\nprint(rotterdam_lulc)\n```"
  },
  {
    "query": "Overlay the NL_Highways.gpkg roads onto NL_Provinces.shp and compute how many highway segments fall inside each province.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          },
          {
            "path": "inputdata\\NL_Highways.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "MultiLineString",
              null
            ],
            "num_features": 60262,
            "fields": [
              "roadId_identifier",
              "roadNationalCode",
              "roadName_localName",
              "roadName_localNameLanguage",
              "roadName_nameEng",
              "EURoadId",
              "annualTrafficFlow",
              "length",
              "linkToReferenceDataset",
              "linkToReferenceObject",
              "inspireId_localId",
              "inspireId_namespace",
              "inspireId_versionId",
              "geometry"
            ],
            "bounds": [
              13596.858800001442,
              307279.8308000006,
              278021.4043999985,
              606213.3302000016
            ]
          },
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          }
        ],
        "python_docs": [
          "ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)",
          "The enumeration of GEOS geometry types.",
          "eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:25.201587+00:00\", \"library\": \"geopandas\", \"object_name\": \"geopandas.clip\"}\n\n[Python_docs] The enumeration of GEOS geometry types.\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:26.129711+00:00\", \"object_name\": \"shapely.GeometryType\", \"library\": \"shapely\"}\n\n[Python_docs] eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:25.201744+00:00\", \"object_name\": \"geopandas.sjoin_nearest\", \"library\": \"geopandas\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"crs\": \"EPSG:28992\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"type\": \"vector\", \"num_features\": 14, \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Highways.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"MultiLineString\",\n    null\n  ],\n  \"num_features\": 60262,\n  \"fields\": [\n    \"roadId_identifier\",\n    \"roadNationalCode\",\n    \"roadName_localName\",\n    \"roadName_localNameLanguage\",\n    \"roadName_nameEng\",\n    \"EURoadId\",\n    \"annualTrafficFlow\",\n    \"length\",\n    \"linkToReferenceDataset\",\n    \"linkToReferenceObject\",\n    \"inspireId_localId\",\n    \"inspireId_namespace\",\n    \"inspireId_versionId\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13596.858800001442,\n    307279.8308000006,\n    278021.4043999985,\n    606213.3302000016\n  ]\n}\nMetadata: {\"bounds\": \"[13596.858800001442, 307279.8308000006, 278021.4043999985, 606213.3302000016]\", \"fields\": \"[\\\"roadId_identifier\\\", \\\"roadNationalCode\\\", \\\"roadName_localName\\\", \\\"roadName_localNameLanguage\\\", \\\"roadName_nameEng\\\", \\\"EURoadId\\\", \\\"annualTrafficFlow\\\", \\\"length\\\", \\\"linkToReferenceDataset\\\", \\\"linkToReferenceObject\\\", \\\"inspireId_localId\\\", \\\"inspireId_namespace\\\", \\\"inspireId_versionId\\\", \\\"geometry\\\"]\", \"num_features\": 60262, \"path\": \"inputdata\\\\NL_Highways.gpkg\", \"geometry_type\": \"[\\\"MultiLineString\\\", null]\", \"type\": \"vector\", \"crs\": \"EPSG:28992\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"type\": \"vector\", \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"num_features\": 2338483, \"crs\": \"EPSG:28992\", \"geometry_type\": \"[\\\"Polygon\\\"]\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\"}"
    ],
    "response": "```python\nimport geopandas as gpd\nfrom shapely.geometry import Point, LineString\n\n# Load the input layers\nnl_provinces = gpd.read_file('inputdata\\\\NL_Provinces.shp')\nnl_highways = gpd.read_file('inputdata\\\\NL_Highways.gpkg')\n\n# Convert highway geometry to LineString for easier overlaying\nnl_highways['geometry'] = nl_highways.apply(lambda row: LineString(row.geometry) if row.geometry else None, axis=1)\n\n# Overlay the highways onto the provinces\noverlayed_highways = gpd.sjoin(nl_provinces, nl_highways, how='inner', op='within')\n\n# Compute how many highway segments fall inside each province\nhighway_segments_per_province = overlayed_highways['geometry'].apply(lambda line: len(line) if isinstance(line, LineString) else 0)\n\n# Print the results\nprint(highway_segments_per_province)\n```"
  },
  {
    "query": "Clip the Netherlands_Landuse.gpkg polygons using the boundary of RotterdamLULC.shp and save the clipped output to a new file.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          },
          {
            "path": "inputdata\\RotterdamLULC.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 9729,
            "fields": [
              "id",
              "OBJECTID",
              "country",
              "fua_name",
              "fua_code",
              "code_2018",
              "class_2018",
              "prod_date",
              "identifier",
              "perimeter",
              "area",
              "comment",
              "Shape_Leng",
              "Shape_Area",
              "geometry"
            ],
            "bounds": [
              84436.32742184984,
              430538.6686652378,
              101190.75927472248,
              445600.6355960344
            ]
          },
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          }
        ],
        "python_docs": [
          "Clip points, lines, or polygon geometries to the mask extent.\n\nBoth layers must be in the same Coordinate Reference System (CRS).\nThe ``gdf`` will be clipped to the full extent of the clip object.\n\nIf there are multiple polygons in mask, data from ``gdf`` will be\nclipped to the total boundary of all polygons in mask.\n\nIf the ``mask`` is list-like with four elements ``(minx, miny, maxx, maxy)``, a\nfaster rectangle clipping algorithm will be used. Note that this can lead to\nslightly different results in edge cases, e.g. if a line would be reduced to a\npoint, this point might not be returned.\nThe geometry is clipped in a fast but possibly dirty way. The output is not\nguaranteed to be valid. No exceptions will be raised for topological errors.\n\nParameters\n----------\ngdf : GeoDataFrame or GeoSeries\n    Vector layer (point, line, polygon) to be clipped to mask.\nmask : GeoDataFrame, GeoSeries, (Multi)Polygon, list-like\n    Polygon vector layer used to clip ``gdf``.\n    The mask's geometry is dissolved into one geometric feature\n    and intersected with ``gdf``.\n    If the mask is list-like with four elements ``(minx, miny, maxx, maxy)``,\n    ``clip`` will use a faster rectangle clipping (",
          "dissolved into one geometric feature\n    and intersected with ``gdf``.\n    If the mask is list-like with four elements ``(minx, miny, maxx, maxy)``,\n    ``clip`` will use a faster rectangle clipping (:meth:`~GeoSeries.clip_by_rect`),\n    possibly leading to slightly different results.\nkeep_geom_type : boolean, default False\n    If True, return only geometries of original type in case of intersection\n    resulting in multiple geometry types or GeometryCollections.\n    If False, return all resulting geometries (potentially mixed-types).\nsort : boolean, default False\n    If True, the results will be sorted in ascending order using the\n    geometries' indexes as the primary key.\n\nReturns\n-------\nGeoDataFrame or GeoSeries\n     Vector data (points, lines, polygons) from ``gdf`` clipped to\n     polygon boundary from mask.\n\nSee Also\n--------\nGeoDataFrame.clip : equivalent GeoDataFrame method\nGeoSeries.clip : equivalent GeoSeries method\n\nExamples\n--------\nClip points (grocery stores) with polygons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"communit",
          "Create polygons formed from the linework of a set of Geometries.\n\nPolygonizes an array of Geometries that contain linework which\nrepresents the edges of a planar graph. Any type of Geometry may be\nprovided as input; only the constituent lines and rings will be used to\ncreate the output polygons.\n\nLines or rings that when combined do not completely close a polygon\nwill result in an empty GeometryCollection.  Duplicate segments are\nignored.\n\nThis function returns the polygons within a GeometryCollection.\nIndividual Polygons can be obtained using ``get_geometry`` to get\na single polygon or ``get_parts`` to get an array of polygons.\nMultiPolygons can be constructed from the output using\n``shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries)))``.\n\nParameters\n----------\ngeometries : array_like\n    An array of geometries.\naxis : int\n    Axis along which the geometries are polygonized.\n    The default is to perform a reduction over the last dimension\n    of the input array. A 1D array results in a scalar geometry.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nReturns\n-------\nGeometryCollection or array of GeometryCollections\n\nSee A"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] Clip points, lines, or polygon geometries to the mask extent.\n\nBoth layers must be in the same Coordinate Reference System (CRS).\nThe ``gdf`` will be clipped to the full extent of the clip object.\n\nIf there are multiple polygons in mask, data from ``gdf`` will be\nclipped to the total boundary of all polygons in mask.\n\nIf the ``mask`` is list-like with four elements ``(minx, miny, maxx, maxy)``, a\nfaster rectangle clipping algorithm will be used. Note that this can lead to\nslightly different results in edge cases, e.g. if a line would be reduced to a\npoint, this point might not be returned.\nThe geometry is clipped in a fast but possibly dirty way. The output is not\nguaranteed to be valid. No exceptions will be raised for topological errors.\n\nParameters\n----------\ngdf : GeoDataFrame or GeoSeries\n    Vector layer (point, line, polygon) to be clipped to mask.\nmask : GeoDataFrame, GeoSeries, (Multi)Polygon, list-like\n    Polygon vector layer used to clip ``gdf``.\n    The mask's geometry is dissolved into one geometric feature\n    and intersected with ``gdf``.\n    If the mask is list-like with four elements ``(minx, miny, maxx, maxy)``,\n    ``clip`` will use a faster rectangle clipping (\nMetadata: {\"object_name\": \"geopandas.clip\", \"retrieved_at\": \"2025-11-20T13:02:25.201578+00:00\", \"library\": \"geopandas\"}\n\n[Python_docs] dissolved into one geometric feature\n    and intersected with ``gdf``.\n    If the mask is list-like with four elements ``(minx, miny, maxx, maxy)``,\n    ``clip`` will use a faster rectangle clipping (:meth:`~GeoSeries.clip_by_rect`),\n    possibly leading to slightly different results.\nkeep_geom_type : boolean, default False\n    If True, return only geometries of original type in case of intersection\n    resulting in multiple geometry types or GeometryCollections.\n    If False, return all resulting geometries (potentially mixed-types).\nsort : boolean, default False\n    If True, the results will be sorted in ascending order using the\n    geometries' indexes as the primary key.\n\nReturns\n-------\nGeoDataFrame or GeoSeries\n     Vector data (points, lines, polygons) from ``gdf`` clipped to\n     polygon boundary from mask.\n\nSee Also\n--------\nGeoDataFrame.clip : equivalent GeoDataFrame method\nGeoSeries.clip : equivalent GeoSeries method\n\nExamples\n--------\nClip points (grocery stores) with polygons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"communit\nMetadata: {\"object_name\": \"geopandas.clip\", \"retrieved_at\": \"2025-11-20T13:02:25.201583+00:00\", \"library\": \"geopandas\"}\n\n[Python_docs] Create polygons formed from the linework of a set of Geometries.\n\nPolygonizes an array of Geometries that contain linework which\nrepresents the edges of a planar graph. Any type of Geometry may be\nprovided as input; only the constituent lines and rings will be used to\ncreate the output polygons.\n\nLines or rings that when combined do not completely close a polygon\nwill result in an empty GeometryCollection.  Duplicate segments are\nignored.\n\nThis function returns the polygons within a GeometryCollection.\nIndividual Polygons can be obtained using ``get_geometry`` to get\na single polygon or ``get_parts`` to get an array of polygons.\nMultiPolygons can be constructed from the output using\n``shapely.multipolygons(shapely.get_parts(shapely.polygonize(geometries)))``.\n\nParameters\n----------\ngeometries : array_like\n    An array of geometries.\naxis : int\n    Axis along which the geometries are polygonized.\n    The default is to perform a reduction over the last dimension\n    of the input array. A 1D array results in a scalar geometry.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nReturns\n-------\nGeometryCollection or array of GeometryCollections\n\nSee A\nMetadata: {\"library\": \"shapely\", \"object_name\": \"shapely.polygonize\", \"retrieved_at\": \"2025-11-20T13:02:26.130443+00:00\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"geometry_type\": \"[\\\"Polygon\\\"]\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\", \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"num_features\": 2338483, \"type\": \"vector\", \"crs\": \"EPSG:28992\", \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\RotterdamLULC.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 9729,\n  \"fields\": [\n    \"id\",\n    \"OBJECTID\",\n    \"country\",\n    \"fua_name\",\n    \"fua_code\",\n    \"code_2018\",\n    \"class_2018\",\n    \"prod_date\",\n    \"identifier\",\n    \"perimeter\",\n    \"area\",\n    \"comment\",\n    \"Shape_Leng\",\n    \"Shape_Area\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    84436.32742184984,\n    430538.6686652378,\n    101190.75927472248,\n    445600.6355960344\n  ]\n}\nMetadata: {\"bounds\": \"[84436.32742184984, 430538.6686652378, 101190.75927472248, 445600.6355960344]\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"num_features\": 9729, \"crs\": \"EPSG:28992\", \"path\": \"inputdata\\\\RotterdamLULC.shp\", \"fields\": \"[\\\"id\\\", \\\"OBJECTID\\\", \\\"country\\\", \\\"fua_name\\\", \\\"fua_code\\\", \\\"code_2018\\\", \\\"class_2018\\\", \\\"prod_date\\\", \\\"identifier\\\", \\\"perimeter\\\", \\\"area\\\", \\\"comment\\\", \\\"Shape_Leng\\\", \\\"Shape_Area\\\", \\\"geometry\\\"]\", \"type\": \"vector\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\", \"crs\": \"EPSG:28992\", \"type\": \"vector\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"num_features\": 14, \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\"}"
    ],
    "response": "```python\nimport geopandas as gpd\n\n# Load the input layers\nnetherlands = gpd.read_file('inputdata\\\\Netherlands_Landuse.gpkg')\nrotterdam = gpd.read_file('inputdata\\\\RotterdamLULC.shp')\n\n# Clip the Netherlands polygons using the Rotterdam boundary\nclipped_netherlands = netherlands.clip(rotterdam)\n\n# Save the clipped output to a new file\nclipped_netherlands.to_file('output\\\\Netherlands_Landuse_clipped.gpkg')\n```"
  },
  {
    "query": "Spatially join the NL_spoorwegen.gpkg point dataset with NL_Provinces.shp to find which province each railway point belongs to.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          },
          {
            "path": "inputdata\\NL_spoorwegen.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Point"
            ],
            "num_features": 34834,
            "fields": [
              "objectid",
              "geocode",
              "subcode",
              "geosubcode",
              "geocode_nr",
              "geocode_naam",
              "km_geocode",
              "km_geocode_t",
              "geokmt",
              "x",
              "y",
              "latitude",
              "longitude",
              "kmlint",
              "kmlint_omschrijving",
              "geldig_vanaf",
              "publicatiedatum",
              "rotatie",
              "geometry"
            ],
            "bounds": [
              30303.949000000954,
              304419.38699999824,
              286566.65900000185,
              609413.949000001
            ]
          },
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          }
        ],
        "python_docs": [
          "Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataFrame.sjoin_nearest : equivalent method\n\nNotes\n-----\nSince this join relies on distances, results will be inaccurate\nif your geometries are in a geographic CRS.\n\nEvery operation in GeoPandas is planar, i.e. the potential third\ndimension is not taken into account.",
          "eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF",
          "ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataFrame.sjoin_nearest : equivalent method\n\nNotes\n-----\nSince this join relies on distances, results will be inaccurate\nif your geometries are in a geographic CRS.\n\nEvery operation in GeoPandas is planar, i.e. the potential third\ndimension is not taken into account.\nMetadata: {\"object_name\": \"geopandas.sjoin_nearest\", \"library\": \"geopandas\", \"retrieved_at\": \"2025-11-20T13:02:25.201748+00:00\"}\n\n[Python_docs] eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF\nMetadata: {\"library\": \"geopandas\", \"retrieved_at\": \"2025-11-20T13:02:25.201744+00:00\", \"object_name\": \"geopandas.sjoin_nearest\"}\n\n[Python_docs] ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)\nMetadata: {\"object_name\": \"geopandas.clip\", \"retrieved_at\": \"2025-11-20T13:02:25.201587+00:00\", \"library\": \"geopandas\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"crs\": \"EPSG:28992\", \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\", \"type\": \"vector\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"num_features\": 14, \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_spoorwegen.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Point\"\n  ],\n  \"num_features\": 34834,\n  \"fields\": [\n    \"objectid\",\n    \"geocode\",\n    \"subcode\",\n    \"geosubcode\",\n    \"geocode_nr\",\n    \"geocode_naam\",\n    \"km_geocode\",\n    \"km_geocode_t\",\n    \"geokmt\",\n    \"x\",\n    \"y\",\n    \"latitude\",\n    \"longitude\",\n    \"kmlint\",\n    \"kmlint_omschrijving\",\n    \"geldig_vanaf\",\n    \"publicatiedatum\",\n    \"rotatie\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    30303.949000000954,\n    304419.38699999824,\n    286566.65900000185,\n    609413.949000001\n  ]\n}\nMetadata: {\"type\": \"vector\", \"crs\": \"EPSG:28992\", \"geometry_type\": \"[\\\"Point\\\"]\", \"fields\": \"[\\\"objectid\\\", \\\"geocode\\\", \\\"subcode\\\", \\\"geosubcode\\\", \\\"geocode_nr\\\", \\\"geocode_naam\\\", \\\"km_geocode\\\", \\\"km_geocode_t\\\", \\\"geokmt\\\", \\\"x\\\", \\\"y\\\", \\\"latitude\\\", \\\"longitude\\\", \\\"kmlint\\\", \\\"kmlint_omschrijving\\\", \\\"geldig_vanaf\\\", \\\"publicatiedatum\\\", \\\"rotatie\\\", \\\"geometry\\\"]\", \"bounds\": \"[30303.949000000954, 304419.38699999824, 286566.65900000185, 609413.949000001]\", \"num_features\": 34834, \"path\": \"inputdata\\\\NL_spoorwegen.gpkg\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"crs\": \"EPSG:28992\", \"type\": \"vector\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\", \"geometry_type\": \"[\\\"Polygon\\\"]\", \"num_features\": 2338483, \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\"}"
    ],
    "response": "```python\nimport geopandas as gpd\n\n# Load the NL_Provinces.shp and NL_spoorwegen.gpkg datasets\nnl_provinces = gpd.read_file('inputdata\\\\NL_Provinces.shp')\nnl_spoorwegen = gpd.read_file('inputdata\\\\NL_spoorwegen.gpkg')\n\n# Perform a spatial join on the two datasets, using the 'geometry' column as the join key\njoined_data = nl_provinces.sjoin(nl_spoorwegen, how='left', op='intersects')\n\n# Print the joined dataset\nprint(joined_data)\n```"
  },
  {
    "query": "Using Netherlands_Landuse.gpkg, compute the percentage of land area occupied by each gewas category in the entire dataset.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          },
          {
            "path": "inputdata\\RotterdamLULC.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 9729,
            "fields": [
              "id",
              "OBJECTID",
              "country",
              "fua_name",
              "fua_code",
              "code_2018",
              "class_2018",
              "prod_date",
              "identifier",
              "perimeter",
              "area",
              "comment",
              "Shape_Leng",
              "Shape_Area",
              "geometry"
            ],
            "bounds": [
              84436.32742184984,
              430538.6686652378,
              101190.75927472248,
              445600.6355960344
            ]
          },
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          }
        ],
        "python_docs": [
          "Compute the area of a (multi)polygon.\n\nParameters\n----------\ngeometry : Geometry or array_like\n    Geometry or geometries for which to compute the area.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import MultiPolygon, Polygon\n>>> polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)])\n>>> shapely.area(polygon)\n100.0\n>>> polygon2 = Polygon([(10, 10), (10, 20), (20, 20), (20, 10), (10, 10)])\n>>> shapely.area(MultiPolygon([polygon, polygon2]))\n200.0\n>>> shapely.area(Polygon())\n0.0\n>>> shapely.area(None)\nnan",
          "Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n>>> area3 = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n\n``area1`` and ``area2`` have a common border:\n\n>>> shapely.contains(area1, area2)\nTrue\n>>> shapely.contains_properly(area1, area2)\nFalse\n\n``area3`` is completely inside ``area1`` with no common border:\n\n>>> shapely.contains(area1, area3)\nTrue\n>>> shapely.contains_properly(area1, area3)\nTrue",
          "on.area\n1.0"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] Compute the area of a (multi)polygon.\n\nParameters\n----------\ngeometry : Geometry or array_like\n    Geometry or geometries for which to compute the area.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import MultiPolygon, Polygon\n>>> polygon = Polygon([(0, 0), (0, 10), (10, 10), (10, 0), (0, 0)])\n>>> shapely.area(polygon)\n100.0\n>>> polygon2 = Polygon([(10, 10), (10, 20), (20, 20), (20, 10), (10, 10)])\n>>> shapely.area(MultiPolygon([polygon, polygon2]))\n200.0\n>>> shapely.area(Polygon())\n0.0\n>>> shapely.area(None)\nnan\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:26.129755+00:00\", \"object_name\": \"shapely.area\", \"library\": \"shapely\"}\n\n[Python_docs] Polygon([(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)])\n>>> area3 = Polygon([(1, 1), (2, 1), (2, 2), (1, 2), (1, 1)])\n\n``area1`` and ``area2`` have a common border:\n\n>>> shapely.contains(area1, area2)\nTrue\n>>> shapely.contains_properly(area1, area2)\nFalse\n\n``area3`` is completely inside ``area1`` with no common border:\n\n>>> shapely.contains(area1, area3)\nTrue\n>>> shapely.contains_properly(area1, area3)\nTrue\nMetadata: {\"library\": \"shapely\", \"retrieved_at\": \"2025-11-20T13:02:26.129829+00:00\", \"object_name\": \"shapely.contains_properly\"}\n\n[Python_docs] on.area\n1.0\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:26.129740+00:00\", \"library\": \"shapely\", \"object_name\": \"shapely.Polygon\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\", \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\", \"type\": \"vector\", \"num_features\": 2338483, \"geometry_type\": \"[\\\"Polygon\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\RotterdamLULC.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 9729,\n  \"fields\": [\n    \"id\",\n    \"OBJECTID\",\n    \"country\",\n    \"fua_name\",\n    \"fua_code\",\n    \"code_2018\",\n    \"class_2018\",\n    \"prod_date\",\n    \"identifier\",\n    \"perimeter\",\n    \"area\",\n    \"comment\",\n    \"Shape_Leng\",\n    \"Shape_Area\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    84436.32742184984,\n    430538.6686652378,\n    101190.75927472248,\n    445600.6355960344\n  ]\n}\nMetadata: {\"num_features\": 9729, \"bounds\": \"[84436.32742184984, 430538.6686652378, 101190.75927472248, 445600.6355960344]\", \"type\": \"vector\", \"crs\": \"EPSG:28992\", \"fields\": \"[\\\"id\\\", \\\"OBJECTID\\\", \\\"country\\\", \\\"fua_name\\\", \\\"fua_code\\\", \\\"code_2018\\\", \\\"class_2018\\\", \\\"prod_date\\\", \\\"identifier\\\", \\\"perimeter\\\", \\\"area\\\", \\\"comment\\\", \\\"Shape_Leng\\\", \\\"Shape_Area\\\", \\\"geometry\\\"]\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"path\": \"inputdata\\\\RotterdamLULC.shp\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"type\": \"vector\", \"crs\": \"EPSG:28992\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\", \"num_features\": 14}"
    ],
    "response": "```python\nimport pandas as pd\nfrom shapely.geometry import Polygon\nimport numpy as np\n\n# Load data from gpk file\ndata = pd.read_file('inputdata\\\\Netherlands_Landuse.gpkg')\n\n# Compute area of each polygon\nareas = []\nfor index, row in data.iterrows():\n    geom = Polygon(row['geometry'])\n    areas.append(geom.area)\n\n# Compute total area\ntotal_area = sum(areas)\n\n# Group by gewas category and compute percentage of land area occupied\ndata['percentage'] = (data['gewascode'].map({1: 'Gras', 2: 'Bos', 3: 'Zand'})) * (100 / total_area) * areas\n\n# Print the result\nprint(data[['category', 'percentage']])\n```"
  },
  {
    "query": "Find all NL_Highways.gpkg road segments that intersect agricultural areas in Netherlands_Landuse.gpkg and return only those segments with annualTrafficFlow greater than 10000.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          },
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          },
          {
            "path": "inputdata\\RotterdamLULC.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 9729,
            "fields": [
              "id",
              "OBJECTID",
              "country",
              "fua_name",
              "fua_code",
              "code_2018",
              "class_2018",
              "prod_date",
              "identifier",
              "perimeter",
              "area",
              "comment",
              "Shape_Leng",
              "Shape_Area",
              "geometry"
            ],
            "bounds": [
              84436.32742184984,
              430538.6686652378,
              101190.75927472248,
              445600.6355960344
            ]
          }
        ],
        "python_docs": [
          "eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF",
          "ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)",
          "dissolved into one geometric feature\n    and intersected with ``gdf``.\n    If the mask is list-like with four elements ``(minx, miny, maxx, maxy)``,\n    ``clip`` will use a faster rectangle clipping (:meth:`~GeoSeries.clip_by_rect`),\n    possibly leading to slightly different results.\nkeep_geom_type : boolean, default False\n    If True, return only geometries of original type in case of intersection\n    resulting in multiple geometry types or GeometryCollections.\n    If False, return all resulting geometries (potentially mixed-types).\nsort : boolean, default False\n    If True, the results will be sorted in ascending order using the\n    geometries' indexes as the primary key.\n\nReturns\n-------\nGeoDataFrame or GeoSeries\n     Vector data (points, lines, polygons) from ``gdf`` clipped to\n     polygon boundary from mask.\n\nSee Also\n--------\nGeoDataFrame.clip : equivalent GeoDataFrame method\nGeoSeries.clip : equivalent GeoSeries method\n\nExamples\n--------\nClip points (grocery stores) with polygons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"communit"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF\nMetadata: {\"object_name\": \"geopandas.sjoin_nearest\", \"retrieved_at\": \"2025-11-20T13:02:25.201744+00:00\", \"library\": \"geopandas\"}\n\n[Python_docs] ons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"community\"] == \"NEAR WEST SIDE\"]\n>>> groceries = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.groceries\")\n... ).to_crs(chicago.crs)\n>>> groceries.shape\n(148, 8)\n\n>>> nws_groceries = geopandas.clip(groceries, near_west_side)\n>>> nws_groceries.shape\n(7, 8)\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:25.201587+00:00\", \"library\": \"geopandas\", \"object_name\": \"geopandas.clip\"}\n\n[Python_docs] dissolved into one geometric feature\n    and intersected with ``gdf``.\n    If the mask is list-like with four elements ``(minx, miny, maxx, maxy)``,\n    ``clip`` will use a faster rectangle clipping (:meth:`~GeoSeries.clip_by_rect`),\n    possibly leading to slightly different results.\nkeep_geom_type : boolean, default False\n    If True, return only geometries of original type in case of intersection\n    resulting in multiple geometry types or GeometryCollections.\n    If False, return all resulting geometries (potentially mixed-types).\nsort : boolean, default False\n    If True, the results will be sorted in ascending order using the\n    geometries' indexes as the primary key.\n\nReturns\n-------\nGeoDataFrame or GeoSeries\n     Vector data (points, lines, polygons) from ``gdf`` clipped to\n     polygon boundary from mask.\n\nSee Also\n--------\nGeoDataFrame.clip : equivalent GeoDataFrame method\nGeoSeries.clip : equivalent GeoSeries method\n\nExamples\n--------\nClip points (grocery stores) with polygons (the Near West Side community):\n\n>>> import geodatasets\n>>> chicago = geopandas.read_file(\n...     geodatasets.get_path(\"geoda.chicago_health\")\n... )\n>>> near_west_side = chicago[chicago[\"communit\nMetadata: {\"retrieved_at\": \"2025-11-20T13:02:25.201583+00:00\", \"library\": \"geopandas\", \"object_name\": \"geopandas.clip\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"geometry_type\": \"[\\\"Polygon\\\"]\", \"num_features\": 2338483, \"type\": \"vector\", \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\", \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"crs\": \"EPSG:28992\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"crs\": \"EPSG:28992\", \"type\": \"vector\", \"num_features\": 14}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\RotterdamLULC.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 9729,\n  \"fields\": [\n    \"id\",\n    \"OBJECTID\",\n    \"country\",\n    \"fua_name\",\n    \"fua_code\",\n    \"code_2018\",\n    \"class_2018\",\n    \"prod_date\",\n    \"identifier\",\n    \"perimeter\",\n    \"area\",\n    \"comment\",\n    \"Shape_Leng\",\n    \"Shape_Area\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    84436.32742184984,\n    430538.6686652378,\n    101190.75927472248,\n    445600.6355960344\n  ]\n}\nMetadata: {\"type\": \"vector\", \"bounds\": \"[84436.32742184984, 430538.6686652378, 101190.75927472248, 445600.6355960344]\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"num_features\": 9729, \"crs\": \"EPSG:28992\", \"fields\": \"[\\\"id\\\", \\\"OBJECTID\\\", \\\"country\\\", \\\"fua_name\\\", \\\"fua_code\\\", \\\"code_2018\\\", \\\"class_2018\\\", \\\"prod_date\\\", \\\"identifier\\\", \\\"perimeter\\\", \\\"area\\\", \\\"comment\\\", \\\"Shape_Leng\\\", \\\"Shape_Area\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\RotterdamLULC.shp\"}"
    ],
    "response": "```python\nimport geopandas as gpd\n\n# Load the input layers\nnetherlands_landuse = gpd.read_file('inputdata\\\\Netherlands_Landuse.gpkg')\nrotterdam_lulc = gpd.read_file('inputdata\\\\RotterdamLULC.shp')\n\n# Filter the Rotterdam LULC data to only include road segments with annualTrafficFlow > 10000\nroad_segments = rotterdam_lulc[rotterdam_lulc['annualTrafficFlow'] > 10000]\n\n# Perform a spatial join between the road segments and agricultural areas in Netherlands_Landuse.gpkg\nintersections = gpd.sjoin(netherlands_landuse, road_segments, how='inner', op='within')\n\n# Filter the intersections to only include those with annualTrafficFlow > 10000\nresult = intersections[intersections['annualTrafficFlow'] > 10000]\n\nprint(result)\n```"
  },
  {
    "query": "For each province in NL_Provinces.shp, compute (1) the total length of highway segments from NL_Highways.gpkg that lie inside the province (in meters), and (2) the count of railway points from NL_spoorwegen.gpkg that are within 500 meters of any highway segment in that province. Output a table with columns: province_name, highway_length_m, nearby_railway_count.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\NL_Provinces.shp",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon",
              "MultiPolygon"
            ],
            "num_features": 14,
            "fields": [
              "GID_1",
              "GID_0",
              "COUNTRY",
              "NAME_1",
              "VARNAME_1",
              "NL_NAME_1",
              "TYPE_1",
              "ENGTYPE_1",
              "CC_1",
              "HASC_1",
              "ISO_1",
              "geometry"
            ],
            "bounds": [
              13895.494358404569,
              303925.454335885,
              277998.5668456809,
              619270.3070891453
            ]
          },
          {
            "path": "inputdata\\NL_Highways.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "MultiLineString",
              null
            ],
            "num_features": 60262,
            "fields": [
              "roadId_identifier",
              "roadNationalCode",
              "roadName_localName",
              "roadName_localNameLanguage",
              "roadName_nameEng",
              "EURoadId",
              "annualTrafficFlow",
              "length",
              "linkToReferenceDataset",
              "linkToReferenceObject",
              "inspireId_localId",
              "inspireId_namespace",
              "inspireId_versionId",
              "geometry"
            ],
            "bounds": [
              13596.858800001442,
              307279.8308000006,
              278021.4043999985,
              606213.3302000016
            ]
          },
          {
            "path": "inputdata\\NL_spoorwegen.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Point"
            ],
            "num_features": 34834,
            "fields": [
              "objectid",
              "geocode",
              "subcode",
              "geosubcode",
              "geocode_nr",
              "geocode_naam",
              "km_geocode",
              "km_geocode_t",
              "geokmt",
              "x",
              "y",
              "latitude",
              "longitude",
              "kmlint",
              "kmlint_omschrijving",
              "geldig_vanaf",
              "publicatiedatum",
              "rotatie",
              "geometry"
            ],
            "bounds": [
              30303.949000000954,
              304419.38699999824,
              286566.65900000185,
              609413.949000001
            ]
          }
        ],
        "python_docs": [
          "eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF",
          "Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataFrame.sjoin_nearest : equivalent method\n\nNotes\n-----\nSince this join relies on distances, results will be inaccurate\nif your geometries are in a geographic CRS.\n\nEvery operation in GeoPandas is planar, i.e. the potential third\ndimension is not taken into account.",
          "Compute the total bounds (extent) of the geometry.\n\nParameters\n----------\ngeometry : Geometry or array_like\n    Geometry or geometries for which to compute the total bounds.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nReturns\n-------\nnumpy ndarray of [xmin, ymin, xmax, ymax]\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import LineString, Point, Polygon\n>>> shapely.total_bounds(Point(2, 3)).tolist()\n[2.0, 3.0, 2.0, 3.0]\n>>> shapely.total_bounds([Point(2, 3), Point(4, 5)]).tolist()\n[2.0, 3.0, 4.0, 5.0]\n>>> shapely.total_bounds([\n...     LineString([(0, 1), (0, 2), (3, 2)]),\n...     LineString([(4, 4), (4, 6), (6, 7)])\n... ]).tolist()\n[0.0, 1.0, 6.0, 7.0]\n>>> shapely.total_bounds(Polygon()).tolist()\n[nan, nan, nan, nan]\n>>> shapely.total_bounds([Polygon(), Point(2, 3)]).tolist()\n[2.0, 3.0, 2.0, 3.0]\n>>> shapely.total_bounds(None).tolist()\n[nan, nan, nan, nan]"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] eometry\"]].head(2)\n               Chain    community                                geometry\n0     VIET HOA PLAZA       UPTOWN   MULTIPOINT ((1168268.672 1933554.35))\n1  COUNTY FAIR FOODS  MORGAN PARK  MULTIPOINT ((1162302.618 1832900.224))\n\n\nTo include the distances:\n\n>>> groceries_w_communities = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\")\n>>> groceries_w_communities[[\"Chain\", \"community\", \"distances\"]].head(2)\n               Chain    community  distances\n0     VIET HOA PLAZA       UPTOWN        0.0\n1  COUNTY FAIR FOODS  MORGAN PARK        0.0\n\nIn the following example, we get multiple groceries for Uptown because all\nresults are equidistant (in this case zero because they intersect).\nIn fact, we get 4 results in total:\n\n>>> chicago_w_groceries = geopandas.sjoin_nearest(groceries, chicago, distance_col=\"distances\", how=\"right\")\n>>> uptown_results = chicago_w_groceries[chicago_w_groceries[\"community\"] == \"UPTOWN\"]\n>>> uptown_results[[\"Chain\", \"community\"]]\n            Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataF\nMetadata: {\"library\": \"geopandas\", \"object_name\": \"geopandas.sjoin_nearest\", \"retrieved_at\": \"2025-11-20T13:02:25.201744+00:00\"}\n\n[Python_docs] Chain community\n30  VIET HOA PLAZA    UPTOWN\n30      JEWEL OSCO    UPTOWN\n30          TARGET    UPTOWN\n30       Mariano's    UPTOWN\n\nSee Also\n--------\nsjoin : binary predicate joins\nGeoDataFrame.sjoin_nearest : equivalent method\n\nNotes\n-----\nSince this join relies on distances, results will be inaccurate\nif your geometries are in a geographic CRS.\n\nEvery operation in GeoPandas is planar, i.e. the potential third\ndimension is not taken into account.\nMetadata: {\"library\": \"geopandas\", \"object_name\": \"geopandas.sjoin_nearest\", \"retrieved_at\": \"2025-11-20T13:02:25.201748+00:00\"}\n\n[Python_docs] Compute the total bounds (extent) of the geometry.\n\nParameters\n----------\ngeometry : Geometry or array_like\n    Geometry or geometries for which to compute the total bounds.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nReturns\n-------\nnumpy ndarray of [xmin, ymin, xmax, ymax]\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import LineString, Point, Polygon\n>>> shapely.total_bounds(Point(2, 3)).tolist()\n[2.0, 3.0, 2.0, 3.0]\n>>> shapely.total_bounds([Point(2, 3), Point(4, 5)]).tolist()\n[2.0, 3.0, 4.0, 5.0]\n>>> shapely.total_bounds([\n...     LineString([(0, 1), (0, 2), (3, 2)]),\n...     LineString([(4, 4), (4, 6), (6, 7)])\n... ]).tolist()\n[0.0, 1.0, 6.0, 7.0]\n>>> shapely.total_bounds(Polygon()).tolist()\n[nan, nan, nan, nan]\n>>> shapely.total_bounds([Polygon(), Point(2, 3)]).tolist()\n[2.0, 3.0, 2.0, 3.0]\n>>> shapely.total_bounds(None).tolist()\n[nan, nan, nan, nan]\nMetadata: {\"object_name\": \"shapely.total_bounds\", \"library\": \"shapely\", \"retrieved_at\": \"2025-11-20T13:02:26.130599+00:00\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Provinces.shp\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\",\n    \"MultiPolygon\"\n  ],\n  \"num_features\": 14,\n  \"fields\": [\n    \"GID_1\",\n    \"GID_0\",\n    \"COUNTRY\",\n    \"NAME_1\",\n    \"VARNAME_1\",\n    \"NL_NAME_1\",\n    \"TYPE_1\",\n    \"ENGTYPE_1\",\n    \"CC_1\",\n    \"HASC_1\",\n    \"ISO_1\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13895.494358404569,\n    303925.454335885,\n    277998.5668456809,\n    619270.3070891453\n  ]\n}\nMetadata: {\"type\": \"vector\", \"path\": \"inputdata\\\\NL_Provinces.shp\", \"geometry_type\": \"[\\\"Polygon\\\", \\\"MultiPolygon\\\"]\", \"fields\": \"[\\\"GID_1\\\", \\\"GID_0\\\", \\\"COUNTRY\\\", \\\"NAME_1\\\", \\\"VARNAME_1\\\", \\\"NL_NAME_1\\\", \\\"TYPE_1\\\", \\\"ENGTYPE_1\\\", \\\"CC_1\\\", \\\"HASC_1\\\", \\\"ISO_1\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\", \"num_features\": 14, \"bounds\": \"[13895.494358404569, 303925.454335885, 277998.5668456809, 619270.3070891453]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Highways.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"MultiLineString\",\n    null\n  ],\n  \"num_features\": 60262,\n  \"fields\": [\n    \"roadId_identifier\",\n    \"roadNationalCode\",\n    \"roadName_localName\",\n    \"roadName_localNameLanguage\",\n    \"roadName_nameEng\",\n    \"EURoadId\",\n    \"annualTrafficFlow\",\n    \"length\",\n    \"linkToReferenceDataset\",\n    \"linkToReferenceObject\",\n    \"inspireId_localId\",\n    \"inspireId_namespace\",\n    \"inspireId_versionId\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13596.858800001442,\n    307279.8308000006,\n    278021.4043999985,\n    606213.3302000016\n  ]\n}\nMetadata: {\"type\": \"vector\", \"path\": \"inputdata\\\\NL_Highways.gpkg\", \"bounds\": \"[13596.858800001442, 307279.8308000006, 278021.4043999985, 606213.3302000016]\", \"geometry_type\": \"[\\\"MultiLineString\\\", null]\", \"crs\": \"EPSG:28992\", \"num_features\": 60262, \"fields\": \"[\\\"roadId_identifier\\\", \\\"roadNationalCode\\\", \\\"roadName_localName\\\", \\\"roadName_localNameLanguage\\\", \\\"roadName_nameEng\\\", \\\"EURoadId\\\", \\\"annualTrafficFlow\\\", \\\"length\\\", \\\"linkToReferenceDataset\\\", \\\"linkToReferenceObject\\\", \\\"inspireId_localId\\\", \\\"inspireId_namespace\\\", \\\"inspireId_versionId\\\", \\\"geometry\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_spoorwegen.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Point\"\n  ],\n  \"num_features\": 34834,\n  \"fields\": [\n    \"objectid\",\n    \"geocode\",\n    \"subcode\",\n    \"geosubcode\",\n    \"geocode_nr\",\n    \"geocode_naam\",\n    \"km_geocode\",\n    \"km_geocode_t\",\n    \"geokmt\",\n    \"x\",\n    \"y\",\n    \"latitude\",\n    \"longitude\",\n    \"kmlint\",\n    \"kmlint_omschrijving\",\n    \"geldig_vanaf\",\n    \"publicatiedatum\",\n    \"rotatie\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    30303.949000000954,\n    304419.38699999824,\n    286566.65900000185,\n    609413.949000001\n  ]\n}\nMetadata: {\"num_features\": 34834, \"type\": \"vector\", \"bounds\": \"[30303.949000000954, 304419.38699999824, 286566.65900000185, 609413.949000001]\", \"fields\": \"[\\\"objectid\\\", \\\"geocode\\\", \\\"subcode\\\", \\\"geosubcode\\\", \\\"geocode_nr\\\", \\\"geocode_naam\\\", \\\"km_geocode\\\", \\\"km_geocode_t\\\", \\\"geokmt\\\", \\\"x\\\", \\\"y\\\", \\\"latitude\\\", \\\"longitude\\\", \\\"kmlint\\\", \\\"kmlint_omschrijving\\\", \\\"geldig_vanaf\\\", \\\"publicatiedatum\\\", \\\"rotatie\\\", \\\"geometry\\\"]\", \"crs\": \"EPSG:28992\", \"geometry_type\": \"[\\\"Point\\\"]\", \"path\": \"inputdata\\\\NL_spoorwegen.gpkg\"}"
    ],
    "response": "```python\nimport geopandas as gpd\nfrom shapely.geometry import Polygon\nimport numpy as np\n\n# Load the input data\nnl_provinces = gpd.read_file('inputdata/NL_Provinces.shp')\nnl_highways = gpd.read_file('inputdata/NL_Highways.gpkg')\nnl_spoorwegen = gpd.read_file('inputdata/NL_spoorwegen.gpkg')\n\n# Compute the total bounds (extent) of each province\nprovince_bounds = nl_provinces.geometry.apply(lambda geom: geom.bounds)\n\n# Initialize an empty list to store the results\nresults = []\n\n# Iterate over each province\nfor index, row in nl_provinces.iterrows():\n    # Get the bounds of the current province\n    province_bounds_xy = province_bounds.loc[index]\n    \n    # Filter the highway segments that lie inside the province\n    highway_segments_inside_province = nl_highways[nl_highways.geometry.intersects(Polygon(province_bounds_xy))]\n    \n    # Compute the total length of highway segments inside the province (in meters)\n    highway_length_m = highway_segments_inside_province['geometry'].apply(lambda geom: geom.length).sum()\n    \n    # Filter the railway points that are within 500 meters of any highway segment in the province\n    nearby_railway_points = nl_spoorwegen[nl_spoorwegen.geometry.distance(nl_highways.geometry) <= 500]\n    \n    # Compute the count of railway points inside the province\n    nearby_railway_count = len(nearby_railway_points)\n    \n    # Append the results to the list\n    results.append({\n        'province_name': row['NAME_1'],\n        'highway_length_m': highway_length_m,\n        'nearby_railway_count': nearby_railway_count\n    })\n\n# Convert the list of dictionaries to a pandas DataFrame\nresults_df = pd.DataFrame(results)\n\n# Print the resulting table\nprint(results_df)\n```"
  },
  {
    "query": "Create a merged geospatial dataset that links NL_spoorwegen.gpkg railway points to the nearest highway segment in NL_Highways.gpkg and compute the distance between them using Shapely.",
    "retrieved_context": [
      {
        "input_layers": [
          {
            "path": "inputdata\\NL_spoorwegen.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Point"
            ],
            "num_features": 34834,
            "fields": [
              "objectid",
              "geocode",
              "subcode",
              "geosubcode",
              "geocode_nr",
              "geocode_naam",
              "km_geocode",
              "km_geocode_t",
              "geokmt",
              "x",
              "y",
              "latitude",
              "longitude",
              "kmlint",
              "kmlint_omschrijving",
              "geldig_vanaf",
              "publicatiedatum",
              "rotatie",
              "geometry"
            ],
            "bounds": [
              30303.949000000954,
              304419.38699999824,
              286566.65900000185,
              609413.949000001
            ]
          },
          {
            "path": "inputdata\\NL_Highways.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "MultiLineString",
              null
            ],
            "num_features": 60262,
            "fields": [
              "roadId_identifier",
              "roadNationalCode",
              "roadName_localName",
              "roadName_localNameLanguage",
              "roadName_nameEng",
              "EURoadId",
              "annualTrafficFlow",
              "length",
              "linkToReferenceDataset",
              "linkToReferenceObject",
              "inspireId_localId",
              "inspireId_namespace",
              "inspireId_versionId",
              "geometry"
            ],
            "bounds": [
              13596.858800001442,
              307279.8308000006,
              278021.4043999985,
              606213.3302000016
            ]
          },
          {
            "path": "inputdata\\Netherlands_Landuse.gpkg",
            "type": "vector",
            "crs": "EPSG:28992",
            "geometry_type": [
              "Polygon"
            ],
            "num_features": 2338483,
            "fields": [
              "category",
              "gewas",
              "gewascode",
              "jaar",
              "status",
              "geometry"
            ],
            "bounds": [
              13653.612700000405,
              306853.58900000155,
              277837.5870000012,
              612868.2639999986
            ]
          }
        ],
        "python_docs": [
          "Compute the discrete Fr\u00e9chet distance between two geometries.\n\nThe Fr\u00e9chet distance is a measure of similarity: it is the greatest\ndistance between any point in A and the closest point in B. The discrete\ndistance is an approximation of this metric: only vertices are considered.\nThe parameter 'densify' makes this approximation less coarse by splitting\nthe line segments between vertices before computing the distance.\n\nFr\u00e9chet distance sweep continuously along their respective curves\nand the direction of curves is significant. This makes it a better measure\nof similarity than Hausdorff distance for curve or surface matching.\n\nParameters\n----------\na, b : Geometry or array_like\n    Geometry or geometries to compute the distance between.\ndensify : float or array_like, optional\n    The value of densify is required to be between 0 and 1.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import LineString\n>>> line1 = LineString([(0, 0), (100, 0)])\n>>> line2 = LineString([(0, 0), (50, 50), (100, 0)])\n>>> shapely.frechet_distance(line1, line2)\n70.71067811865476\n>>> shapely.frechet_distance(line1, line2",
          "Compute the discrete Hausdorff distance between two geometries.\n\nThe Hausdorff distance is a measure of similarity: it is the greatest\ndistance between any point in A and the closest point in B. The discrete\ndistance is an approximation of this metric: only vertices are considered.\nThe parameter 'densify' makes this approximation less coarse by splitting\nthe line segments between vertices before computing the distance.\n\nParameters\n----------\na, b : Geometry or array_like\n    Geometry or geometries to compute the distance between.\ndensify : float or array_like, optional\n    The value of densify is required to be between 0 and 1.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import LineString\n>>> line1 = LineString([(130, 0), (0, 0), (0, 150)])\n>>> line2 = LineString([(10, 10), (10, 150), (130, 10)])\n>>> shapely.hausdorff_distance(line1, line2)\n14.142135623730951\n>>> shapely.hausdorff_distance(line1, line2, densify=0.5)\n70.0\n>>> shapely.hausdorff_distance(line1, LineString())\nnan\n>>> shapely.hausdorff_distance(line1, None)\nnan",
          "g\n>>> line1 = LineString([(0, 0), (100, 0)])\n>>> line2 = LineString([(0, 0), (50, 50), (100, 0)])\n>>> shapely.frechet_distance(line1, line2)\n70.71067811865476\n>>> shapely.frechet_distance(line1, line2, densify=0.5)\n50.0\n>>> shapely.frechet_distance(line1, LineString())\nnan\n>>> shapely.frechet_distance(line1, None)\nnan"
        ],
        "pyqgis_docs": []
      },
      "[Python_docs] Compute the discrete Fr\u00e9chet distance between two geometries.\n\nThe Fr\u00e9chet distance is a measure of similarity: it is the greatest\ndistance between any point in A and the closest point in B. The discrete\ndistance is an approximation of this metric: only vertices are considered.\nThe parameter 'densify' makes this approximation less coarse by splitting\nthe line segments between vertices before computing the distance.\n\nFr\u00e9chet distance sweep continuously along their respective curves\nand the direction of curves is significant. This makes it a better measure\nof similarity than Hausdorff distance for curve or surface matching.\n\nParameters\n----------\na, b : Geometry or array_like\n    Geometry or geometries to compute the distance between.\ndensify : float or array_like, optional\n    The value of densify is required to be between 0 and 1.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import LineString\n>>> line1 = LineString([(0, 0), (100, 0)])\n>>> line2 = LineString([(0, 0), (50, 50), (100, 0)])\n>>> shapely.frechet_distance(line1, line2)\n70.71067811865476\n>>> shapely.frechet_distance(line1, line2\nMetadata: {\"library\": \"shapely\", \"object_name\": \"shapely.frechet_distance\", \"retrieved_at\": \"2025-11-20T13:02:26.129966+00:00\"}\n\n[Python_docs] Compute the discrete Hausdorff distance between two geometries.\n\nThe Hausdorff distance is a measure of similarity: it is the greatest\ndistance between any point in A and the closest point in B. The discrete\ndistance is an approximation of this metric: only vertices are considered.\nThe parameter 'densify' makes this approximation less coarse by splitting\nthe line segments between vertices before computing the distance.\n\nParameters\n----------\na, b : Geometry or array_like\n    Geometry or geometries to compute the distance between.\ndensify : float or array_like, optional\n    The value of densify is required to be between 0 and 1.\n**kwargs\n    See :ref:`NumPy ufunc docs <ufuncs.kwargs>` for other keyword arguments.\n\nExamples\n--------\n>>> import shapely\n>>> from shapely import LineString\n>>> line1 = LineString([(130, 0), (0, 0), (0, 150)])\n>>> line2 = LineString([(10, 10), (10, 150), (130, 10)])\n>>> shapely.hausdorff_distance(line1, line2)\n14.142135623730951\n>>> shapely.hausdorff_distance(line1, line2, densify=0.5)\n70.0\n>>> shapely.hausdorff_distance(line1, LineString())\nnan\n>>> shapely.hausdorff_distance(line1, None)\nnan\nMetadata: {\"library\": \"shapely\", \"object_name\": \"shapely.hausdorff_distance\", \"retrieved_at\": \"2025-11-20T13:02:26.130112+00:00\"}\n\n[Python_docs] g\n>>> line1 = LineString([(0, 0), (100, 0)])\n>>> line2 = LineString([(0, 0), (50, 50), (100, 0)])\n>>> shapely.frechet_distance(line1, line2)\n70.71067811865476\n>>> shapely.frechet_distance(line1, line2, densify=0.5)\n50.0\n>>> shapely.frechet_distance(line1, LineString())\nnan\n>>> shapely.frechet_distance(line1, None)\nnan\nMetadata: {\"library\": \"shapely\", \"object_name\": \"shapely.frechet_distance\", \"retrieved_at\": \"2025-11-20T13:02:26.129969+00:00\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_spoorwegen.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Point\"\n  ],\n  \"num_features\": 34834,\n  \"fields\": [\n    \"objectid\",\n    \"geocode\",\n    \"subcode\",\n    \"geosubcode\",\n    \"geocode_nr\",\n    \"geocode_naam\",\n    \"km_geocode\",\n    \"km_geocode_t\",\n    \"geokmt\",\n    \"x\",\n    \"y\",\n    \"latitude\",\n    \"longitude\",\n    \"kmlint\",\n    \"kmlint_omschrijving\",\n    \"geldig_vanaf\",\n    \"publicatiedatum\",\n    \"rotatie\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    30303.949000000954,\n    304419.38699999824,\n    286566.65900000185,\n    609413.949000001\n  ]\n}\nMetadata: {\"crs\": \"EPSG:28992\", \"type\": \"vector\", \"geometry_type\": \"[\\\"Point\\\"]\", \"bounds\": \"[30303.949000000954, 304419.38699999824, 286566.65900000185, 609413.949000001]\", \"num_features\": 34834, \"path\": \"inputdata\\\\NL_spoorwegen.gpkg\", \"fields\": \"[\\\"objectid\\\", \\\"geocode\\\", \\\"subcode\\\", \\\"geosubcode\\\", \\\"geocode_nr\\\", \\\"geocode_naam\\\", \\\"km_geocode\\\", \\\"km_geocode_t\\\", \\\"geokmt\\\", \\\"x\\\", \\\"y\\\", \\\"latitude\\\", \\\"longitude\\\", \\\"kmlint\\\", \\\"kmlint_omschrijving\\\", \\\"geldig_vanaf\\\", \\\"publicatiedatum\\\", \\\"rotatie\\\", \\\"geometry\\\"]\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\NL_Highways.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"MultiLineString\",\n    null\n  ],\n  \"num_features\": 60262,\n  \"fields\": [\n    \"roadId_identifier\",\n    \"roadNationalCode\",\n    \"roadName_localName\",\n    \"roadName_localNameLanguage\",\n    \"roadName_nameEng\",\n    \"EURoadId\",\n    \"annualTrafficFlow\",\n    \"length\",\n    \"linkToReferenceDataset\",\n    \"linkToReferenceObject\",\n    \"inspireId_localId\",\n    \"inspireId_namespace\",\n    \"inspireId_versionId\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13596.858800001442,\n    307279.8308000006,\n    278021.4043999985,\n    606213.3302000016\n  ]\n}\nMetadata: {\"fields\": \"[\\\"roadId_identifier\\\", \\\"roadNationalCode\\\", \\\"roadName_localName\\\", \\\"roadName_localNameLanguage\\\", \\\"roadName_nameEng\\\", \\\"EURoadId\\\", \\\"annualTrafficFlow\\\", \\\"length\\\", \\\"linkToReferenceDataset\\\", \\\"linkToReferenceObject\\\", \\\"inspireId_localId\\\", \\\"inspireId_namespace\\\", \\\"inspireId_versionId\\\", \\\"geometry\\\"]\", \"path\": \"inputdata\\\\NL_Highways.gpkg\", \"num_features\": 60262, \"bounds\": \"[13596.858800001442, 307279.8308000006, 278021.4043999985, 606213.3302000016]\", \"geometry_type\": \"[\\\"MultiLineString\\\", null]\", \"type\": \"vector\", \"crs\": \"EPSG:28992\"}\n\n[input_layers] {\n  \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\",\n  \"type\": \"vector\",\n  \"crs\": \"EPSG:28992\",\n  \"geometry_type\": [\n    \"Polygon\"\n  ],\n  \"num_features\": 2338483,\n  \"fields\": [\n    \"category\",\n    \"gewas\",\n    \"gewascode\",\n    \"jaar\",\n    \"status\",\n    \"geometry\"\n  ],\n  \"bounds\": [\n    13653.612700000405,\n    306853.58900000155,\n    277837.5870000012,\n    612868.2639999986\n  ]\n}\nMetadata: {\"type\": \"vector\", \"geometry_type\": \"[\\\"Polygon\\\"]\", \"num_features\": 2338483, \"path\": \"inputdata\\\\Netherlands_Landuse.gpkg\", \"fields\": \"[\\\"category\\\", \\\"gewas\\\", \\\"gewascode\\\", \\\"jaar\\\", \\\"status\\\", \\\"geometry\\\"]\", \"bounds\": \"[13653.612700000405, 306853.58900000155, 277837.5870000012, 612868.2639999986]\", \"crs\": \"EPSG:28992\"}"
    ],
    "response": "```python\nimport shapely\nfrom shapely.geometry import Point, LineString\nimport geopandas as gpd\n\n# Load input data\ngdf_spoorwegen = gpd.read_file('inputdata\\\\NL_spoorwegen.gpkg')\ngdf_highways = gpd.read_file('inputdata\\\\NL_Highways.gpkg')\n\n# Create a new column 'distance' in the merged dataset\ndef calculate_distance(row):\n    # Find the nearest highway segment for each railway point\n    nearest_highway = gdf_highways.loc[gdf_highways.geometry.distance(row['geometry']).idxmin()]\n    \n    # Calculate the distance between the railway point and the nearest highway segment\n    distance = row['geometry'].distance(nearest_highway.geometry)\n    \n    return distance\n\ngdf_merged = gdf_spoorwegen.copy()\ngdf_merged['distance'] = gdf_merged.apply(calculate_distance, axis=1)\n\n# Compute the discrete Fr\u00e9chet distance between railway points and highway segments\ndef frechet_distance(row):\n    # Find the nearest highway segment for each railway point\n    nearest_highway = gdf_highways.loc[gdf_highways.geometry.distance(row['geometry']).idxmin()]\n    \n    # Calculate the discrete Fr\u00e9chet distance\n    if row['geometry'].is_point:\n        return shapely.frechet_distance(row['geometry'], nearest_highway.geometry)\n    else:\n        return None\n\ngdf_merged['frechet_distance'] = gdf_merged.apply(frechet_distance, axis=1)\n\n# Compute the discrete Hausdorff distance between railway points and highway segments\ndef hausdorff_distance(row):\n    # Find the nearest highway segment for each railway point\n    nearest_highway = gdf_highways.loc[gdf_highways.geometry.distance(row['geometry']).idxmin()]\n    \n    # Calculate the discrete Hausdorff distance\n    if row['geometry'].is_point:\n        return shapely.hausdorff_distance(row['geometry'], nearest_highway.geometry)\n    else:\n        return None\n\ngdf_merged['hausdorff_distance'] = gdf_merged.apply(hausdorff_distance, axis=1)\n\n# Print the merged dataset\nprint(gdf_merged)\n```"
  }
]